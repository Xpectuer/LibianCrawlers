import{_ as o,c as e,o as l,a3 as t}from"./chunks/framework.w8luOYmq.js";const g=JSON.parse('{"title":"1-什么是 Worker","description":"","frontmatter":{},"headers":[],"relativePath":"develop/worker/whats-worker.md","filePath":"develop/worker/whats-worker.md","lastUpdated":1756460431000}'),i={name:"develop/worker/whats-worker.md"};function a(s,r,n,p,c,d){return l(),e("div",null,r[0]||(r[0]=[t('<h1 id="_1-什么是-worker" tabindex="-1">1-什么是 Worker <a class="header-anchor" href="#_1-什么是-worker" aria-label="Permalink to &quot;1-什么是 Worker&quot;">​</a></h1><h2 id="_1-1-设计动机" tabindex="-1">1.1 设计动机 <a class="header-anchor" href="#_1-1-设计动机" aria-label="Permalink to &quot;1.1 设计动机&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">INFO</p><p>在经典语境下的 Worker 通常是指集群中的执行者 —— 与之相对的，还有一个中心化的控制台。这是大型企业偏爱的架构，但不适合个人或小团队使用，原因如下：</p><ol><li><p><strong>环境差异</strong>：家用电脑通常只有少数几台，复杂的集群控制和容错机制无用武之地。同时，企业级调度系统往往缺乏针对单个任务的精细化控制，如暂停、恢复、批次流式传输、双向事件传递等。</p></li><li><p><strong>动态与不确定性</strong>：家庭环境中的闲置电脑随时可能被他人使用。这要求任务调度策略必须非常灵活，能够应对节点的动态变化。</p></li></ol></div><p>为了在家庭或小型办公环境中有效部署任务调度服务，我们需要解决以下核心问题：</p><ol><li><p><strong>复杂的任务生命周期管理</strong>：</p><ul><li>必须支持任务的暂停、恢复和中止，以应对计算资源的临时征用。</li><li>在某些场景下，需要通过 <code>OpenCV</code> 等视觉库监控进程窗口，以处理图形界面的确认对话框或模拟用户点击。</li><li>当某个节点下线时，任务需要能够迁移到其他可用节点上，并包含相应的状态恢复和数据去重策略。</li></ul></li><li><p><strong>用户友好的交互界面 (GUI)</strong>：</p><ul><li>需要为非技术用户（如设备所有者）提供一个直观易用的本地控制界面，提高他们部署和维护节点的意愿。</li><li>需要设计合理的资源分配和权限管理机制，以便让内网之外的协作者也能安全地使用系统。</li></ul></li></ol><p>由于以上这些偏向去中心化和灵活性的需求，市面上现有的框架难以完全满足，因此我们决定自行设计和实现 Worker。</p><h2 id="_1-2-核心设计理念" tabindex="-1">1.2 核心设计理念 <a class="header-anchor" href="#_1-2-核心设计理念" aria-label="Permalink to &quot;1.2 核心设计理念&quot;">​</a></h2><p>LibianCrawler 的 Worker 基于以下核心理念设计：</p><ul><li><p><strong>自治性 (Autonomy)</strong>：每个 Worker 节点都是一个相对独立的单元，能够自主执行任务、管理自身状态，并具备一定的故障自愈能力。</p></li><li><p><strong>对等通信 (Peer-to-Peer Communication)</strong>：尽管存在一个轻量级的任务分发角色，但 Worker 节点之间也具备直接通信的能力，用于任务迁移、状态同步等高级协作场景。</p></li><li><p><strong>资源感知 (Resource-Awareness)</strong>：Worker 能够监控其所在主机的系统资源（CPU、内存），并根据负载情况动态调整任务执行策略，避免对主机造成过度干扰。</p></li><li><p><strong>可扩展性 (Extensibility)</strong>：Worker 的功能是模块化的，可以轻松地通过插件或新模块来扩展其能力，例如增加新的爬虫类型或集成新的数据处理工具。</p></li></ul><h2 id="_1-3-worker-的架构与组件" tabindex="-1">1.3 Worker 的架构与组件 <a class="header-anchor" href="#_1-3-worker-的架构与组件" aria-label="Permalink to &quot;1.3 Worker 的架构与组件&quot;">​</a></h2><p>Worker 主要由以下几个核心组件构成，这些组件在 <code>libiancrawlers/worker/</code> 目录下实现：</p><ul><li><p><strong><code>core.py</code> (执行核心)</strong>：负责任务的实际执行逻辑。它解析 <code>steps/*.json</code> 配置文件，调用相应的爬虫模块（如 Playwright），并管理任务的完整生命周期。</p></li><li><p><strong><code>node.py</code> (节点管理器)</strong>：负责 Worker 节点的网络功能，包括：</p><ul><li><strong>心跳机制</strong>：定期向调度中心报告自身状态（在线、忙碌、空闲）。</li><li><strong>任务接收</strong>：监听来自调度中心的任务指令。</li><li><strong>状态同步</strong>：与其他节点同步信息，为任务迁移做准备。</li></ul></li><li><p><strong><code>ui.py</code> (界面接口)</strong>：作为后端逻辑与前端 <code>worker-ui</code> 之间的桥梁，通过 <code>pywebview</code> 等技术，将任务状态、日志等信息实时推送给本地 GUI，并接收来自 GUI 的用户操作指令（如暂停、恢复任务）。</p></li></ul>',12)]))}const u=o(i,[["render",a]]);export{g as __pageData,u as default};
