import{_ as i,c as a,o as n,ag as t}from"./chunks/framework.B3HI_LuJ.js";const E=JSON.parse('{"title":"3-数据清洗：确保数据质量与一致性","description":"","frontmatter":{},"headers":[],"relativePath":"guide/when-data-clean.md","filePath":"guide/when-data-clean.md","lastUpdated":1752336409000}'),l={name:"guide/when-data-clean.md"};function p(e,s,h,k,r,o){return n(),a("div",null,s[0]||(s[0]=[t(`<h1 id="_3-数据清洗-确保数据质量与一致性" tabindex="-1">3-数据清洗：确保数据质量与一致性 <a class="header-anchor" href="#_3-数据清洗-确保数据质量与一致性" aria-label="Permalink to &quot;3-数据清洗：确保数据质量与一致性&quot;">​</a></h1><p>在数据采集完成后，数据清洗是确保数据质量和一致性的关键步骤。LibianCrawler 提供了一套基于 TypeScript 生态的高效解决方案，针对传统方法中存在的类型推断问题和存储问题进行了优化。</p><h2 id="数据存储-高效管理结构化与非结构化数据" tabindex="-1">数据存储：高效管理结构化与非结构化数据 <a class="header-anchor" href="#数据存储-高效管理结构化与非结构化数据" aria-label="Permalink to &quot;数据存储：高效管理结构化与非结构化数据&quot;">​</a></h2><p>在数据采集中，原始数据会被直接存储到 PostgreSQL 的 垃圾表 中。此外，对于非结构化数据（如图片）我们使用 MinIO 进行存储，并在 PostgreSQL 中保留其访问 URL。</p><ul><li><strong>垃圾表的作用</strong>： <ul><li><strong>原始数据来源</strong>：为后续清洗和转换提供完整的原始数据。</li><li><strong>避免数据损失</strong>：接收大部分采集到的数据，无论其格式或类型是否完美，确保不会因过早丢弃某些字段而导致数据损失。</li></ul></li></ul><p>清洗过程中，我们会从垃圾表中读取数据，进行类型转换、字段提取和合并，最终将结构化的清洗结果数据写入 PostgreSQL 的 清洗结果专用表 中。更多关于数据存储的具体方案可参考 <a href="./when-data-storage-and-visualization.html">下一章节</a> 。</p><h2 id="数据清洗-基于-typescript-的解决方案" tabindex="-1">数据清洗：基于 TypeScript 的解决方案 <a class="header-anchor" href="#数据清洗-基于-typescript-的解决方案" aria-label="Permalink to &quot;数据清洗：基于 TypeScript 的解决方案&quot;">​</a></h2><p>LibianCrawler 的数据清洗流程充分利用了 TypeScript 的类型系统，结合 JSON 查询和转换语言 <a href="https://jsonata.org/" target="_blank" rel="noreferrer">Jsonata</a> 和 类型生成工具 <a href="https://quicktype.io/" target="_blank" rel="noreferrer">Quicktype</a> ，为开发者提供了一套高效且可靠的数据处理方法。</p><h3 id="类型生成-直观识别数据类型" tabindex="-1">类型生成：直观识别数据类型 <a class="header-anchor" href="#类型生成-直观识别数据类型" aria-label="Permalink to &quot;类型生成：直观识别数据类型&quot;">​</a></h3><p>在清洗之前，我们首先需要了解垃圾表中存储的数据结构。通过以下步骤，开发者可以快速生成数据类型的定义：</p><ul><li><strong>从 PostgreSQL 垃圾表迭代读取数据：</strong><ul><li>如果原始数据的类型不够整洁，可以使用 Jsonata 进行预转换。Jsonata 是一种基于 JSON 的查询和转换语言，语法灵活，特别适合处理嵌套结构和树状数据。</li><li>例如：从 DOM 树结构中提取class为某个值的 tag （类似 XPath 的方式遍历数据）。</li></ul></li><li><strong>使用 Quicktype 生成类型定义：</strong><ul><li>将预转换后的迭代器数据输入 Quicktype ，它会自动生成 TypeScript 类型定义。</li><li>这样可以确保垃圾表中所有字段的类型都被准确识别。</li></ul></li></ul><h3 id="数据验证与合并-typescript-的类型检查保障" tabindex="-1">数据验证与合并：TypeScript 的类型检查保障 <a class="header-anchor" href="#数据验证与合并-typescript-的类型检查保障" aria-label="Permalink to &quot;数据验证与合并：TypeScript 的类型检查保障&quot;">​</a></h3><p>在类型生成完成后，进行数据验证和合并：</p><ul><li><strong>数据验证</strong>：利用 TypeScript 的类型系统，对数据进行严格的类型检查，确保数据符合预定义的格式和要求。 <ul><li><strong>严格的类型检查：</strong><ul><li>TypeScript 的类型系统确保清洗过程中难以出现类型错误。</li><li>可以对关键字段（如时间格式、数值范围、网络地址等）进行额外验证，进一步提升数据质量。</li></ul></li><li><strong>及时发现网页变动：</strong><ul><li>如果网页结构发生变化，类型生成结果也会随之改变，从而导致 <code>deno check</code> 类型检查命令失败 和 编辑器类型推断提示报错。这种机制可以帮助开发者快速识别并适应变化。</li></ul></li></ul></li><li><strong>数据合并</strong>：利用 <code>yield*</code> 语法合并生成器，对来自不同来源或具有不同结构的数据进行整合，使其成为统一且完整的数据集。</li></ul><p>TypeScript 的类型安全特性能够有效减少运行时错误，提高代码质量和维护性。通过清晰的类型定义，开发者可以更直观地理解数据结构，从而更高效地处理和分析数据。</p><details class="details custom-block"><summary>伪代码示例: 使用 <a href="https://jsonata.org/" target="_blank" rel="noreferrer">Jsonata</a> 和 <a href="https://quicktype.io/" target="_blank" rel="noreferrer">Quicktype</a> 处理嵌套数据</summary><p>假设我们有以下 JSON 数据：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;users&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;John Doe&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;address&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        &quot;street&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;123 Main St&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        &quot;city&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;New York&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;name&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Jane Smith&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;address&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        &quot;street&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;456 Oak Ave&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        &quot;city&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Los Angeles&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>使用 Jsonata，我们可以提取所有用户的城市信息:</p><blockquote><p>你可以在 <a href="https://try.jsonata.org/" target="_blank" rel="noreferrer">https://try.jsonata.org/</a> 自由尝试 Jsonata 的语法。</p></blockquote><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>users.address.city</span></span></code></pre></div><p>结果将是一个包含 “New York” 和 “Los Angeles” 的数组。</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;New York&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Los Angeles&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><p>然后，将这些数据输入 Quicktype，生成相应的 TypeScript 类型定义：</p><blockquote><p>你可以在 <a href="https://app.quicktype.io/" target="_blank" rel="noreferrer">https://app.quicktype.io/</a> 自由尝试 Quicktype。</p></blockquote><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> number</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  address</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Address</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Address</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  street</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  city</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Awesome !</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  users</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> User</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  jsonata_cities</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>通过这种方式，我们可以快速获得清晰且准确的类型定义，确保在后续的数据处理和分析中保持一致性和正确性。</p></details><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>LibianCrawler 的数据清洗方案通过以下方式解决了传统方法的痛点：</p><ul><li><strong>存储层面：</strong><ul><li>使用 PostgreSQL 存储结构化数据，避免了 CSV 文件的 类型错误、字符集问题、CRLF 问题、体积管理问题。</li><li>非结构化数据通过 MinIO 进行高效存储。</li></ul></li><li><strong>清洗层面：</strong><ul><li>基于 TypeScript 的类型系统，确保数据类型的准确性。</li><li>结合 Jsonata 和 Quicktype，简化了复杂数据的处理和类型生成过程。</li></ul></li></ul><p>这种方案不仅提升了开发效率，还大幅降低了数据错误率，为后续的数据分析和使用奠定了坚实基础。</p>`,20)]))}const g=i(l,[["render",p]]);export{E as __pageData,g as default};
